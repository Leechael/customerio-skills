name: Release

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      release_type:
        description: "Release type"
        required: true
        type: choice
        options: [patch, minor, major]
      ref:
        description: "Branch/ref to release from (default: main)"
        required: false
        type: string
        default: "main"

permissions:
  actions: write
  contents: write
  issues: write
  pull-requests: read

jobs:
  parse:
    if: github.event_name != 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.parse.outputs.should_release }}
      release_type: ${{ steps.parse.outputs.release_type }}
      ref: ${{ steps.parse.outputs.ref }}
      issue_number: ${{ steps.parse.outputs.issue_number }}
      requested_by: ${{ steps.parse.outputs.requested_by }}
    steps:
      - name: Parse release command
        id: parse
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const body = (context.payload.comment?.body || '').trim();
            const actor = context.payload.comment?.user?.login || context.actor;
            const assoc = context.payload.comment?.author_association || '';
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = context.payload.issue?.number || context.payload.pull_request?.number;

            const safeComment = async (message) => {
              if (!issueNumber) {
                core.warning(`No issue number available. message=${message}`);
                return;
              }
              try {
                await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: message });
              } catch (e) {
                core.warning(`Failed to post issue comment: ${e.message}`);
              }
            };

            if (!/!release\b/i.test(body)) {
              return;
            }

            const match = body.match(/^!release\s+(patch|minor|major)\s*$/i);
            if (!match) {
              await safeComment(`@${actor} invalid command. Use: \`!release <patch|minor|major>\`.`);
              return;
            }

            const allowed = ['OWNER', 'MEMBER', 'COLLABORATOR'];
            if (!allowed.includes(assoc)) {
              await safeComment(`@${actor} you are not allowed to trigger release.`);
              return;
            }

            let prNumber = null;
            if (context.eventName === 'issue_comment') {
              if (!context.payload.issue?.pull_request) {
                await safeComment(`@${actor} release command only works in PR comments.`);
                return;
              }
              prNumber = context.payload.issue.number;
            } else if (context.eventName === 'pull_request_review_comment') {
              prNumber = context.payload.pull_request?.number;
            }

            if (!prNumber) {
              await safeComment(`@${actor} unable to resolve PR for release command.`);
              return;
            }

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            if (!pr.head.repo || pr.head.repo.full_name !== `${owner}/${repo}`) {
              await safeComment(`@${actor} release from fork PR is not supported.`);
              return;
            }

            const releaseType = match[1].toLowerCase();
            await safeComment(`Release accepted: bump=${releaseType}, ref=${pr.head.ref}`);
            core.setOutput('should_release', 'true');
            core.setOutput('release_type', releaseType);
            core.setOutput('ref', pr.head.ref);
            core.setOutput('issue_number', String(prNumber));
            core.setOutput('requested_by', actor);

  create-tag:
    needs: [parse]
    if: |
      always() && (
        github.event_name == 'workflow_dispatch' ||
        needs.parse.outputs.should_release == 'true'
      )
    runs-on: ubuntu-latest
    concurrency:
      group: release-${{ github.repository }}
      cancel-in-progress: false
    env:
      RELEASE_TYPE: ${{ github.event_name == 'workflow_dispatch' && inputs.release_type || needs.parse.outputs.release_type }}
      SOURCE_REF: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || needs.parse.outputs.ref }}
      ISSUE_NUMBER: ${{ needs.parse.outputs.issue_number }}
      REQUESTED_BY: ${{ github.event_name == 'workflow_dispatch' && github.actor || needs.parse.outputs.requested_by }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.SOURCE_REF }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Validate naming contract
        run: |
          test -f release-naming.env
          source release-naming.env
          test -n "$TAG_PREFIX"

      - name: Compute next tag
        id: version
        run: |
          set -euo pipefail
          source release-naming.env
          chmod +x ./scripts/next-version.sh
          version=$(./scripts/next-version.sh "$RELEASE_TYPE")
          tag="${TAG_PREFIX}${version}"
          echo "version=${version}" >> "$GITHUB_OUTPUT"
          echo "tag=${tag}" >> "$GITHUB_OUTPUT"

      - name: Create and push tag
        run: |
          tag='${{ steps.version.outputs.tag }}'
          if git rev-parse "$tag" >/dev/null 2>&1; then
            echo "Tag already exists: $tag"
            exit 1
          fi
          git tag "$tag"
          git push origin "$tag"

      - name: Trigger release workflow for new tag
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'release-on-tag.yml',
              ref: 'main',
              inputs: {
                tag: '${{ steps.version.outputs.tag }}'
              }
            });

      - name: Comment success
        if: success() && env.ISSUE_NUMBER != ''
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const body = [
              `Release tag created: \`${{ steps.version.outputs.tag }}\``,
              `- Source ref: \`${process.env.SOURCE_REF}\``,
              `- Requested by: @${process.env.REQUESTED_BY}`
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.ISSUE_NUMBER),
              body
            });

      - name: Comment failure
        if: failure() && env.ISSUE_NUMBER != ''
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.ISSUE_NUMBER),
              body: `Failed to create release tag. Logs: ${runUrl}`
            });
