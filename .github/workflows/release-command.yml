name: Release Command

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      release_type:
        description: "Release type"
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      ref:
        description: "Branch/ref to release from (default: main)"
        required: false
        type: string
        default: "main"

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  parse:
    if: >
      github.event_name == 'issue_comment' &&
      (contains(github.event.comment.body, '!release') ||
       contains(github.event.comment.body, '!Release') ||
       contains(github.event.comment.body, '!RELEASE')) &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.parse.outputs.should_release }}
      release_type: ${{ steps.parse.outputs.release_type }}
      ref: ${{ steps.parse.outputs.ref }}
      issue_number: ${{ steps.parse.outputs.issue_number }}
      requested_by: ${{ steps.parse.outputs.requested_by }}
    steps:
      - name: Parse release command
        id: parse
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const allowedBumps = ['patch', 'minor', 'major'];

            const body = context.payload.comment.body.trim();
            const match = body.match(/!release\s+(patch|minor|major)/i);

            if (!match) {
              const actor = context.payload.comment.user.login;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: [
                  `‚ö†Ô∏è @${actor} I couldn't parse the release command.`,
                  '',
                  'Expected format: `!release <patch|minor|major>`',
                  '',
                  'Examples:',
                  '- `!release patch`',
                  '- `!release minor`',
                  '- `!release major`'
                ].join('\n')
              });
              return;
            }

            const releaseType = match[1].toLowerCase();
            const allowedAssociation = ['OWNER', 'MEMBER', 'COLLABORATOR'];
            const association = context.payload.comment.author_association;
            const actor = context.payload.comment.user.login;
            const issueNumber = context.payload.issue.number;

            if (!allowedAssociation.includes(association)) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: [
                  `‚õî @${actor} you do not have permission to trigger releases.`,
                  '',
                  'Please contact the repository maintainers if this is unexpected.'
                ].join('\n')
              });
              return;
            }

            let ref = 'main';

            if (context.payload.issue.pull_request) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: issueNumber
              });

              if (!pr.head.repo || pr.head.repo.full_name !== `${context.repo.owner}/${context.repo.repo}`) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: [
                    `‚õî @${actor} releases from forked branches are not supported.`,
                    '',
                    'Please push the branch to this repository or run the release manually in Actions.'
                  ].join('\n')
                });
                return;
              }

              ref = pr.head.ref;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: [
                `üöÄ @${actor} release command accepted: \`${releaseType}\` from \`${ref}\`.`,
                '',
                'The release workflow is queued; results will be posted here.'
              ].join('\n')
            });

            core.setOutput('should_release', 'true');
            core.setOutput('release_type', releaseType);
            core.setOutput('ref', ref);
            core.setOutput('issue_number', issueNumber);
            core.setOutput('requested_by', actor);

  create-tag:
    needs: [parse]
    if: |
      always() &&
      (
        (needs.parse.result == 'success' && needs.parse.outputs.should_release == 'true') ||
        (github.event_name == 'workflow_dispatch')
      )
    concurrency:
      group: release-tag
      cancel-in-progress: false
    runs-on: ubuntu-latest
    env:
      RELEASE_TYPE: ${{ github.event_name == 'workflow_dispatch' && inputs.release_type || needs.parse.outputs.release_type }}
      SOURCE_REF: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || needs.parse.outputs.ref }}
      ISSUE_NUMBER: ${{ needs.parse.outputs.issue_number }}
      REQUESTED_BY: ${{ github.event_name == 'workflow_dispatch' && github.actor || needs.parse.outputs.requested_by }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.SOURCE_REF }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Compute next version
        id: version
        run: |
          set -e
          LATEST_TAG=$(git tag -l 'v*' --sort=-version:refname | head -n1)

          if [ -z "$LATEST_TAG" ]; then
            MAJOR=0; MINOR=0; PATCH=0
          else
            VERSION="${LATEST_TAG#v}"
            MAJOR=$(echo "$VERSION" | cut -d. -f1)
            MINOR=$(echo "$VERSION" | cut -d. -f2)
            PATCH=$(echo "$VERSION" | cut -d. -f3)
          fi

          case "$RELEASE_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=v$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "Computed version: v$NEW_VERSION (from ${LATEST_TAG:-none})"

      - name: Create and push tag
        run: |
          git tag -a "${{ steps.version.outputs.tag }}" -m "Release ${{ steps.version.outputs.tag }}"
          git push origin "${{ steps.version.outputs.tag }}"

      - name: Comment success
        if: ${{ success() && env.ISSUE_NUMBER != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.ISSUE_NUMBER),
              body: [
                `üè∑Ô∏è Tag \`${{ steps.version.outputs.tag }}\` created and pushed.`,
                '',
                `The [release workflow](${runUrl}) will build and publish binaries shortly.`
              ].join('\n')
            });

      - name: Comment failure
        if: ${{ failure() && env.ISSUE_NUMBER != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const actor = process.env.REQUESTED_BY ? `@${process.env.REQUESTED_BY}` : 'Requester';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.ISSUE_NUMBER),
              body: [
                `‚ùå ${actor} release failed.`,
                '',
                `Please review the workflow logs: ${runUrl}`
              ].join('\n')
            });
